diff --git a/src/examples/handoffdemo/CMakeLists.txt b/src/examples/handoffdemo/CMakeLists.txt
new file mode 100644
index 000000000..12bda6cff
--- /dev/null
+++ b/src/examples/handoffdemo/CMakeLists.txt
@@ -0,0 +1,20 @@
+
+# Copyright (c) <current-year> <your-organization>
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at:
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+add_vpp_plugin(handoffdemo
+  SOURCES
+  handoffdemo.c
+  node.c
+  handoffdemo.h
+)
diff --git a/src/examples/handoffdemo/README.md b/src/examples/handoffdemo/README.md
new file mode 100644
index 000000000..3787731c7
--- /dev/null
+++ b/src/examples/handoffdemo/README.md
@@ -0,0 +1,186 @@
+# Handoff queue demo plugin
+
+This plugin provides a simplified example of how to hand off
+packets between threads. I used it to debug packet-tracer handoff
+tracing support.
+
+# Packet generator input script
+
+```
+ packet-generator new {
+    name x
+    limit 5
+    size 128-128
+    interface local0
+    node handoffdemo-1
+    data {
+        incrementing 30
+    }
+ }
+```
+# Start vpp with 2 worker threads
+
+The demo plugin hands packets from worker 1 to worker 2.
+
+# Enable tracing, and start the packet generator
+
+```
+  trace add pg-input 100
+  packet-generator enable
+```
+
+# Sample Run
+
+```
+  DBGvpp# ex /tmp/pg_input_script
+  DBGvpp# pa en
+  DBGvpp# sh err
+   Count                    Node                  Reason
+         5              handoffdemo-1             packets handed off processed
+         5              handoffdemo-2             completed packets
+  DBGvpp# show run
+  Thread 1 vpp_wk_0 (lcore 0)
+  Time 133.9, average vectors/node 5.00, last 128 main loops 0.00 per node 0.00
+    vector rates in 3.7331e-2, out 0.0000e0, drop 0.0000e0, punt 0.0000e0
+               Name                 State         Calls          Vectors        Suspends         Clocks       Vectors/Call
+  handoffdemo-1                    active                  1               5               0          4.76e3            5.00
+  pg-input                        disabled                 2               5               0          5.58e4            2.50
+  unix-epoll-input                 polling             22760               0               0          2.14e7            0.00
+  ---------------
+  Thread 2 vpp_wk_1 (lcore 2)
+  Time 133.9, average vectors/node 5.00, last 128 main loops 0.00 per node 0.00
+    vector rates in 0.0000e0, out 0.0000e0, drop 3.7331e-2, punt 0.0000e0
+               Name                 State         Calls          Vectors        Suspends         Clocks       Vectors/Call
+  drop                             active                  1               5               0          1.35e4            5.00
+  error-drop                       active                  1               5               0          2.52e4            5.00
+  handoffdemo-2                    active                  1               5               0          2.56e4            5.00
+  unix-epoll-input                 polling             22406               0               0          2.18e7            0.00
+```
+
+Enable the packet tracer and run it again...
+
+```
+  DBGvpp# trace add pg-input 100
+  DBGvpp# pa en
+  DBGvpp# sh trace
+  sh trace
+  ------------------- Start of thread 0 vpp_main -------------------
+  No packets in trace buffer
+  ------------------- Start of thread 1 vpp_wk_0 -------------------
+  Packet 1
+
+  00:06:50:520688: pg-input
+    stream x, 128 bytes, 0 sw_if_index
+    current data 0, length 128, buffer-pool 0, ref-count 1, trace handle 0x1000000
+    00000000: 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d0000
+    00000020: 0000000000000000000000000000000000000000000000000000000000000000
+    00000040: 0000000000000000000000000000000000000000000000000000000000000000
+    00000060: 0000000000000000000000000000000000000000000000000000000000000000
+  00:06:50:520762: handoffdemo-1
+    HANDOFFDEMO: current thread 1
+
+  Packet 2
+
+  00:06:50:520688: pg-input
+    stream x, 128 bytes, 0 sw_if_index
+    current data 0, length 128, buffer-pool 0, ref-count 1, trace handle 0x1000001
+    00000000: 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d0000
+    00000020: 0000000000000000000000000000000000000000000000000000000000000000
+    00000040: 0000000000000000000000000000000000000000000000000000000000000000
+    00000060: 0000000000000000000000000000000000000000000000000000000000000000
+  00:06:50:520762: handoffdemo-1
+    HANDOFFDEMO: current thread 1
+
+  Packet 3
+
+  00:06:50:520688: pg-input
+    stream x, 128 bytes, 0 sw_if_index
+    current data 0, length 128, buffer-pool 0, ref-count 1, trace handle 0x1000002
+    00000000: 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d0000
+    00000020: 0000000000000000000000000000000000000000000000000000000000000000
+    00000040: 0000000000000000000000000000000000000000000000000000000000000000
+    00000060: 0000000000000000000000000000000000000000000000000000000000000000
+  00:06:50:520762: handoffdemo-1
+    HANDOFFDEMO: current thread 1
+
+  Packet 4
+
+  00:06:50:520688: pg-input
+    stream x, 128 bytes, 0 sw_if_index
+    current data 0, length 128, buffer-pool 0, ref-count 1, trace handle 0x1000003
+    00000000: 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d0000
+    00000020: 0000000000000000000000000000000000000000000000000000000000000000
+    00000040: 0000000000000000000000000000000000000000000000000000000000000000
+    00000060: 0000000000000000000000000000000000000000000000000000000000000000
+  00:06:50:520762: handoffdemo-1
+    HANDOFFDEMO: current thread 1
+
+  Packet 5
+
+  00:06:50:520688: pg-input
+    stream x, 128 bytes, 0 sw_if_index
+    current data 0, length 128, buffer-pool 0, ref-count 1, trace handle 0x1000004
+    00000000: 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d0000
+    00000020: 0000000000000000000000000000000000000000000000000000000000000000
+    00000040: 0000000000000000000000000000000000000000000000000000000000000000
+    00000060: 0000000000000000000000000000000000000000000000000000000000000000
+  00:06:50:520762: handoffdemo-1
+    HANDOFFDEMO: current thread 1
+
+  ------------------- Start of thread 2 vpp_wk_1 -------------------
+  Packet 1
+
+  00:06:50:520796: handoff_trace
+    HANDED-OFF: from thread 1 trace index 0
+  00:06:50:520796: handoffdemo-2
+    HANDOFFDEMO: current thread 2
+  00:06:50:520867: error-drop
+    rx:local0
+  00:06:50:520914: drop
+    handoffdemo-2: completed packets
+
+  Packet 2
+
+  00:06:50:520796: handoff_trace
+    HANDED-OFF: from thread 1 trace index 1
+  00:06:50:520796: handoffdemo-2
+    HANDOFFDEMO: current thread 2
+  00:06:50:520867: error-drop
+    rx:local0
+  00:06:50:520914: drop
+    handoffdemo-2: completed packets
+
+  Packet 3
+
+  00:06:50:520796: handoff_trace
+    HANDED-OFF: from thread 1 trace index 2
+  00:06:50:520796: handoffdemo-2
+    HANDOFFDEMO: current thread 2
+  00:06:50:520867: error-drop
+    rx:local0
+  00:06:50:520914: drop
+    handoffdemo-2: completed packets
+
+  Packet 4
+
+  00:06:50:520796: handoff_trace
+    HANDED-OFF: from thread 1 trace index 3
+  00:06:50:520796: handoffdemo-2
+    HANDOFFDEMO: current thread 2
+  00:06:50:520867: error-drop
+    rx:local0
+  00:06:50:520914: drop
+    handoffdemo-2: completed packets
+
+  Packet 5
+
+  00:06:50:520796: handoff_trace
+    HANDED-OFF: from thread 1 trace index 4
+  00:06:50:520796: handoffdemo-2
+    HANDOFFDEMO: current thread 2
+  00:06:50:520867: error-drop
+    rx:local0
+  00:06:50:520914: drop
+    handoffdemo-2: completed packets
+ DBGvpp#
+```
diff --git a/src/examples/handoffdemo/handoffdemo.c b/src/examples/handoffdemo/handoffdemo.c
new file mode 100644
index 000000000..a1dad44d2
--- /dev/null
+++ b/src/examples/handoffdemo/handoffdemo.c
@@ -0,0 +1,39 @@
+/*
+ * handoffdemo.c - skeleton vpp engine plug-in
+ *
+ * Copyright (c) <current-year> <your-organization>
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <vnet/vnet.h>
+#include <vnet/plugin/plugin.h>
+#include <vpp/app/version.h>
+#include <handoffdemo/handoffdemo.h>
+
+handoffdemo_main_t handoffdemo_main;
+
+/* *INDENT-OFF* */
+VLIB_PLUGIN_REGISTER () =
+{
+  .version = VPP_BUILD_VER,
+  .description = "handoff demo plugin",
+};
+/* *INDENT-ON* */
+
+/*
+ * fd.io coding-style-patch-verification: ON
+ *
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/examples/handoffdemo/handoffdemo.h b/src/examples/handoffdemo/handoffdemo.h
new file mode 100644
index 000000000..558311fe2
--- /dev/null
+++ b/src/examples/handoffdemo/handoffdemo.h
@@ -0,0 +1,50 @@
+
+/*
+ * handoffdemo.h - skeleton vpp engine plug-in header file
+ *
+ * Copyright (c) <current-year> <your-organization>
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef __included_handoffdemo_h__
+#define __included_handoffdemo_h__
+
+#include <vnet/vnet.h>
+#include <vnet/ip/ip.h>
+#include <vnet/ethernet/ethernet.h>
+
+#include <vppinfra/hash.h>
+#include <vppinfra/error.h>
+
+typedef struct
+{
+  u32 frame_queue_index;
+
+
+  /* convenience */
+  vlib_main_t *vlib_main;
+  vnet_main_t *vnet_main;
+} handoffdemo_main_t;
+
+extern handoffdemo_main_t handoffdemo_main;
+
+extern vlib_node_registration_t handoffdemo_node_1, handoffdemo_node_2;
+
+#endif /* __included_handoffdemo_h__ */
+
+/*
+ * fd.io coding-style-patch-verification: ON
+ *
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/examples/handoffdemo/node.c b/src/examples/handoffdemo/node.c
new file mode 100644
index 000000000..2177ccb9d
--- /dev/null
+++ b/src/examples/handoffdemo/node.c
@@ -0,0 +1,241 @@
+/*
+ * node.c - skeleton vpp engine plug-in dual-loop node skeleton
+ *
+ * Copyright (c) <current-year> <your-organization>
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <vlib/vlib.h>
+#include <vnet/vnet.h>
+#include <vnet/pg/pg.h>
+#include <vppinfra/error.h>
+#include <handoffdemo/handoffdemo.h>
+
+typedef struct
+{
+  int current_thread;
+} handoffdemo_trace_t;
+
+/* packet trace format function */
+static u8 *
+format_handoffdemo_trace (u8 * s, va_list * args)
+{
+  CLIB_UNUSED (vlib_main_t * vm) = va_arg (*args, vlib_main_t *);
+  CLIB_UNUSED (vlib_node_t * node) = va_arg (*args, vlib_node_t *);
+  handoffdemo_trace_t *t = va_arg (*args, handoffdemo_trace_t *);
+
+  s = format (s, "HANDOFFDEMO: current thread %d", t->current_thread);
+
+  return s;
+}
+
+vlib_node_registration_t handoffdemo_node;
+
+#define foreach_handoffdemo_error                       \
+_(HANDED_OFF, "packets handed off processed")           \
+_(CONGESTION_DROP, "handoff queue congestion drops")    \
+_(COMPLETE, "completed packets")
+
+typedef enum
+{
+#define _(sym,str) HANDOFFDEMO_ERROR_##sym,
+  foreach_handoffdemo_error
+#undef _
+    HANDOFFDEMO_N_ERROR,
+} handoffdemo_error_t;
+
+static char *handoffdemo_error_strings[] = {
+#define _(sym,string) string,
+  foreach_handoffdemo_error
+#undef _
+};
+
+typedef enum
+{
+  HANDOFFDEMO_NEXT_DROP,
+  HANDOFFDEMO_N_NEXT,
+} handoffdemo_next_t;
+
+always_inline uword
+handoffdemo_inline (vlib_main_t * vm,
+		    vlib_node_runtime_t * node, vlib_frame_t * frame,
+		    int which, int is_trace)
+{
+  handoffdemo_main_t *hmp = &handoffdemo_main;
+  u32 n_left_from, *from;
+  u32 error0 = node->errors[HANDOFFDEMO_ERROR_COMPLETE];
+  vlib_buffer_t *bufs[VLIB_FRAME_SIZE], **b;
+  u16 thread_indices[VLIB_FRAME_SIZE];
+  u16 nexts[VLIB_FRAME_SIZE], *next;
+  u32 n_enq;
+  int i;
+
+  from = vlib_frame_vector_args (frame);
+  n_left_from = frame->n_vectors;
+
+  vlib_get_buffers (vm, from, bufs, n_left_from);
+  next = nexts;
+  b = bufs;
+
+  /* First thread */
+  if (which == 1)
+    {
+      for (i = 0; i < frame->n_vectors; i++)
+	{
+	  /* Pick a thread to handle this packet */
+	  thread_indices[i] = 2;
+
+	  if (is_trace && (b[0]->flags & VLIB_BUFFER_IS_TRACED))
+	    {
+	      handoffdemo_trace_t *t = vlib_add_trace (vm, node, b[0],
+						       sizeof (*t));
+	      t->current_thread = vm->thread_index;
+	    }
+
+	  b += 1;
+	  next += 1;
+	  n_left_from -= 1;
+	}
+
+      /* Enqueue buffers to threads */
+      n_enq =
+	vlib_buffer_enqueue_to_thread (vm, hmp->frame_queue_index,
+				       from, thread_indices, frame->n_vectors,
+				       1 /* drop on congestion */ );
+      if (n_enq < frame->n_vectors)
+	vlib_node_increment_counter (vm, node->node_index,
+				     HANDOFFDEMO_ERROR_CONGESTION_DROP,
+				     frame->n_vectors - n_enq);
+      vlib_node_increment_counter (vm, node->node_index,
+				   HANDOFFDEMO_ERROR_HANDED_OFF, n_enq);
+      return frame->n_vectors;
+    }
+  else				/* Second thread */
+    {
+      u32 *from;
+
+      from = vlib_frame_vector_args (frame);
+      n_left_from = frame->n_vectors;
+
+      vlib_get_buffers (vm, from, bufs, n_left_from);
+      next = nexts;
+      b = bufs;
+
+      while (n_left_from > 0)
+	{
+	  if (is_trace && (b[0]->flags & VLIB_BUFFER_IS_TRACED))
+	    {
+	      handoffdemo_trace_t *t = vlib_add_trace (vm, node, b[0],
+						       sizeof (*t));
+	      t->current_thread = vm->thread_index;
+	    }
+
+	  next[0] = HANDOFFDEMO_NEXT_DROP;
+	  b[0]->error = error0;
+	  next++;
+	  b++;
+	  n_left_from--;
+	}
+
+      vlib_buffer_enqueue_to_next (vm, node, from, (u16 *) nexts,
+				   frame->n_vectors);
+    }
+
+  return frame->n_vectors;
+}
+
+static uword
+handoffdemo_node_1_fn (vlib_main_t * vm,
+		       vlib_node_runtime_t * node, vlib_frame_t * frame)
+{
+  if (PREDICT_FALSE (node->flags & VLIB_NODE_FLAG_TRACE))
+    return handoffdemo_inline (vm, node, frame, 1 /* which */ ,
+			       1 /* is_trace */ );
+  else
+    return handoffdemo_inline (vm, node, frame, 1 /* which */ ,
+			       0 /* is_trace */ );
+}
+
+/* *INDENT-OFF* */
+VLIB_REGISTER_NODE (handoffdemo_node_1) =
+{
+  .name = "handoffdemo-1",
+  .function = handoffdemo_node_1_fn,
+  .vector_size = sizeof (u32),
+  .format_trace = format_handoffdemo_trace,
+  .type = VLIB_NODE_TYPE_INTERNAL,
+
+  .n_errors = ARRAY_LEN(handoffdemo_error_strings),
+  .error_strings = handoffdemo_error_strings,
+
+  .n_next_nodes = HANDOFFDEMO_N_NEXT,
+
+  /* edit / add dispositions here */
+  .next_nodes = {
+        [HANDOFFDEMO_NEXT_DROP] = "error-drop",
+  },
+};
+/* *INDENT-ON* */
+
+uword
+handoffdemo_node_2_fn (vlib_main_t * vm,
+		       vlib_node_runtime_t * node, vlib_frame_t * frame)
+{
+  if (PREDICT_FALSE (node->flags & VLIB_NODE_FLAG_TRACE))
+    return handoffdemo_inline (vm, node, frame, 2 /* which */ ,
+			       1 /* is_trace */ );
+  else
+    return handoffdemo_inline (vm, node, frame, 2 /* which */ ,
+			       0 /* is_trace */ );
+}
+
+/* *INDENT-OFF* */
+VLIB_REGISTER_NODE (handoffdemo_node_2) =
+{
+  .name = "handoffdemo-2",
+  .function = handoffdemo_node_2_fn,
+  .vector_size = sizeof (u32),
+  .format_trace = format_handoffdemo_trace,
+  .type = VLIB_NODE_TYPE_INTERNAL,
+
+  .n_errors = ARRAY_LEN(handoffdemo_error_strings),
+  .error_strings = handoffdemo_error_strings,
+
+  .n_next_nodes = HANDOFFDEMO_N_NEXT,
+
+  /* edit / add dispositions here */
+  .next_nodes = {
+        [HANDOFFDEMO_NEXT_DROP] = "error-drop",
+  },
+};
+/* *INDENT-ON* */
+
+static clib_error_t *
+handoffdemo_node_init (vlib_main_t * vm)
+{
+  handoffdemo_main_t *hmp = &handoffdemo_main;
+
+  hmp->frame_queue_index = vlib_frame_queue_main_init
+    (handoffdemo_node_2.index, 16);
+
+  return 0;
+}
+
+VLIB_INIT_FUNCTION (handoffdemo_node_init);
+
+/*
+ * fd.io coding-style-patch-verification: ON
+ *
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/vlib/CMakeLists.txt b/src/vlib/CMakeLists.txt
index acd66359f..1cecf5fb1 100644
--- a/src/vlib/CMakeLists.txt
+++ b/src/vlib/CMakeLists.txt
@@ -52,6 +52,7 @@ add_vpp_library(vlib
   drop.c
   error.c
   format.c
+  handoff_trace.c
   i2c.c
   init.c
   linux/pci.c
diff --git a/src/vlib/buffer.c b/src/vlib/buffer.c
index 21e91026b..a49200d1b 100644
--- a/src/vlib/buffer.c
+++ b/src/vlib/buffer.c
@@ -112,7 +112,7 @@ format_vlib_buffer (u8 * s, va_list * args)
 		b->total_length_not_including_first_buffer);
 
   if (b->flags & VLIB_BUFFER_IS_TRACED)
-    s = format (s, ", trace 0x%x", b->trace_index);
+    s = format (s, ", trace handle 0x%x", b->trace_handle);
 
   if (a)
     s = format (s, "\n%U%v", format_white_space, indent, a);
diff --git a/src/vlib/buffer.h b/src/vlib/buffer.h
index 0fd57f527..c8761af4d 100644
--- a/src/vlib/buffer.h
+++ b/src/vlib/buffer.h
@@ -158,9 +158,9 @@ typedef union
     /** start of 2nd cache line */
       CLIB_CACHE_LINE_ALIGN_MARK (cacheline1);
 
-    /** Specifies index into trace buffer if VLIB_PACKET_IS_TRACED flag is
+    /** Specifies trace buffer handle if VLIB_PACKET_IS_TRACED flag is
       * set. */
-    u32 trace_index;
+    u32 trace_handle;
 
     /** Only valid for first buffer in chain. Current length plus total length
       * given here give total number of bytes in buffer chain. */
@@ -354,6 +354,44 @@ vlib_buffer_make_headroom (vlib_buffer_t * b, u8 size)
   return vlib_buffer_get_current (b);
 }
 
+/** \brief Construct a trace handle from thread and pool index
+ * @param thread Thread id
+ * @param pool_index Pool index
+ * @return trace handle
+ */
+always_inline u32
+vlib_buffer_make_trace_handle (u32 thread, u32 pool_index)
+{
+  u32 rv;
+  ASSERT (thread < 0xff);
+  ASSERT (pool_index < 0x00FFFFFF);
+  rv = (thread << 24) | (pool_index & 0x00FFFFFF);
+  return rv;
+}
+
+/** \brief Extract the thread id from a trace handle
+ * @param trace_handle the trace handle
+ * @return the thread id
+ */
+always_inline u32
+vlib_buffer_get_trace_thread (vlib_buffer_t * b)
+{
+  u32 trace_handle = b->trace_handle;
+
+  return trace_handle >> 24;
+}
+
+/** \brief Extract the trace (pool) index from a trace handle
+ * @param trace_handle the trace handle
+ * @return the trace index
+ */
+always_inline u32
+vlib_buffer_get_trace_index (vlib_buffer_t * b)
+{
+  u32 trace_handle = b->trace_handle;
+  return trace_handle & 0x00FFFFFF;
+}
+
 /** \brief Retrieve bytes from buffer head
  * @param b     pointer to the buffer
  * @param size  number of bytes to pull
diff --git a/src/vlib/handoff_trace.c b/src/vlib/handoff_trace.c
new file mode 100644
index 000000000..7a6743885
--- /dev/null
+++ b/src/vlib/handoff_trace.c
@@ -0,0 +1,125 @@
+/*
+ * handoff_trace.c - used to generate handoff trace records
+ *
+ * Copyright (c) 2019 Cisco Systems and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <vlib/vlib.h>
+#include <vnet/vnet.h>
+#include <vnet/pg/pg.h>
+#include <vppinfra/error.h>
+
+typedef struct
+{
+  u32 prev_thread;
+  u32 prev_trace_index;
+} handoff_trace_t;
+
+/* packet trace format function */
+static u8 *
+format_handoff_trace (u8 * s, va_list * args)
+{
+  CLIB_UNUSED (vlib_main_t * vm) = va_arg (*args, vlib_main_t *);
+  CLIB_UNUSED (vlib_node_t * node) = va_arg (*args, vlib_node_t *);
+  handoff_trace_t *t = va_arg (*args, handoff_trace_t *);
+
+  s = format (s, "HANDED-OFF: from thread %d trace index %d",
+	      t->prev_thread, t->prev_trace_index);
+  return s;
+}
+
+static vlib_node_registration_t handoff_trace_node;
+
+#define foreach_handoff_trace_error \
+_(BUGS, "Warning: packets sent to the handoff trace node!")
+
+typedef enum
+{
+#define _(sym,str) HANDOFF_TRACE_ERROR_##sym,
+  foreach_handoff_trace_error
+#undef _
+    HANDOFF_TRACE_N_ERROR,
+} handoff_trace_error_t;
+
+static char *handoff_trace_error_strings[] = {
+#define _(sym,string) string,
+  foreach_handoff_trace_error
+#undef _
+};
+
+static uword
+handoff_trace_node_fn (vlib_main_t * vm,
+		       vlib_node_runtime_t * node, vlib_frame_t * frame)
+{
+  vlib_buffer_free (vm, vlib_frame_vector_args (frame), frame->n_vectors);
+
+  vlib_node_increment_counter (vm, node->node_index,
+			       HANDOFF_TRACE_ERROR_BUGS, frame->n_vectors);
+
+  return frame->n_vectors;
+}
+
+typedef enum
+{
+  HANDOFF_TRACE_NEXT_DROP,
+  HANDOFF_TRACE_N_NEXT,
+} tdummy_next_t;
+
+/* *INDENT-OFF* */
+VLIB_REGISTER_NODE (handoff_trace_node, static) =
+{
+  .name = "handoff_trace",
+  .function = handoff_trace_node_fn,
+  .vector_size = sizeof (u32),
+  .format_trace = format_handoff_trace,
+  .type = VLIB_NODE_TYPE_INTERNAL,
+  .n_next_nodes = HANDOFF_TRACE_N_NEXT,
+
+  /* edit / add dispositions here */
+  .next_nodes = {
+    [HANDOFF_TRACE_NEXT_DROP] = "error-drop",
+  },
+
+  .n_errors = ARRAY_LEN(handoff_trace_error_strings),
+  .error_strings = handoff_trace_error_strings,
+};
+/* *INDENT-ON* */
+
+void
+vlib_add_handoff_trace (vlib_main_t * vm, vlib_buffer_t * b)
+{
+  u32 prev_thread = vlib_buffer_get_trace_thread (b);
+  u32 prev_trace_index = vlib_buffer_get_trace_index (b);
+  handoff_trace_t *t;
+  vlib_node_runtime_t *node
+    = vlib_node_get_runtime (vm, handoff_trace_node.index);
+
+  vlib_trace_buffer (vm, node, 0 /* fake next frame index */ ,
+		     b, 1 /* folllow chain */ );
+
+  t = vlib_add_trace (vm, node, b, sizeof (*t));
+
+  t->prev_thread = prev_thread;
+  t->prev_trace_index = prev_trace_index;
+}
+
+
+/* *INDENT-ON* */
+
+/*
+ * fd.io coding-style-patch-verification: ON
+ *
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/vlib/main.c b/src/vlib/main.c
index 43400f859..3c0e75416 100644
--- a/src/vlib/main.c
+++ b/src/vlib/main.c
@@ -1019,8 +1019,8 @@ format_buffer_metadata (u8 * s, va_list * args)
 	      (u32) (b->error), (u32) (b->ref_count),
 	      (u32) (b->buffer_pool_index));
   s = format (s,
-	      "trace_index: %d, len_not_first_buf: %d\n",
-	      b->trace_index, b->total_length_not_including_first_buffer);
+	      "trace_handle: 0x%x, len_not_first_buf: %d\n",
+	      b->trace_handle, b->total_length_not_including_first_buffer);
   return s;
 }
 
@@ -1091,7 +1091,8 @@ dispatch_pcap_trace (vlib_main_t * vm,
 	  if (PREDICT_FALSE (b->flags & VLIB_BUFFER_IS_TRACED))
 	    {
 	      vlib_trace_header_t **h
-		= pool_elt_at_index (tm->trace_buffer_pool, b->trace_index);
+		= pool_elt_at_index (tm->trace_buffer_pool,
+				     vlib_buffer_get_trace_index (b));
 
 	      vm->pcap_buffer = format (vm->pcap_buffer, "%U%c",
 					format_vlib_trace, vm, h[0], 0);
diff --git a/src/vlib/threads.c b/src/vlib/threads.c
index 297c977c4..911253872 100644
--- a/src/vlib/threads.c
+++ b/src/vlib/threads.c
@@ -1673,6 +1673,7 @@ vlib_frame_queue_dequeue (vlib_main_t * vm, vlib_frame_queue_main_t * fqm)
 
   while (1)
     {
+      vlib_buffer_t *b;
       if (fq->head == fq->tail)
 	{
 	  fq->head_hint = fq->head;
@@ -1695,6 +1696,11 @@ vlib_frame_queue_dequeue (vlib_main_t * vm, vlib_frame_queue_main_t * fqm)
 
       f = vlib_get_frame_to_node (vm, fqm->node_index);
 
+      /* If the first vector is traced, set the frame trace flag */
+      b = vlib_get_buffer (vm, from[0]);
+      if (b->flags & VLIB_BUFFER_IS_TRACED)
+	f->frame_flags |= VLIB_NODE_FLAG_TRACE;
+
       to = vlib_frame_vector_args (f);
 
       n_left_to_node = elt->n_vectors;
diff --git a/src/vlib/trace_funcs.h b/src/vlib/trace_funcs.h
index 56cbfc7b6..257c3a3a4 100644
--- a/src/vlib/trace_funcs.h
+++ b/src/vlib/trace_funcs.h
@@ -45,14 +45,12 @@ extern u8 *vnet_trace_dummy;
 always_inline void
 vlib_validate_trace (vlib_trace_main_t * tm, vlib_buffer_t * b)
 {
-  /*
-   * this assert seems right, but goes off constantly.
-   * disabling it appears to make the pain go away
-   */
-  ASSERT (1 || b->flags & VLIB_BUFFER_IS_TRACED);
-  ASSERT (!pool_is_free_index (tm->trace_buffer_pool, b->trace_index));
+  ASSERT (!pool_is_free_index (tm->trace_buffer_pool,
+			       vlib_buffer_get_trace_index (b)));
 }
 
+void vlib_add_handoff_trace (vlib_main_t * vm, vlib_buffer_t * b);
+
 always_inline void *
 vlib_add_trace (vlib_main_t * vm,
 		vlib_node_runtime_t * r, vlib_buffer_t * b, u32 n_data_bytes)
@@ -76,11 +74,15 @@ vlib_add_trace (vlib_main_t * vm,
       return vnet_trace_dummy;
     }
 
+  /* Are we trying to trace a handoff case? */
+  if (PREDICT_FALSE (vlib_buffer_get_trace_thread (b) != vm->thread_index))
+    vlib_add_handoff_trace (vm, b);
+
   vlib_validate_trace (tm, b);
 
   n_data_bytes = round_pow2 (n_data_bytes, sizeof (h[0]));
   n_data_words = n_data_bytes / sizeof (h[0]);
-  vec_add2_aligned (tm->trace_buffer_pool[b->trace_index], h,
+  vec_add2_aligned (tm->trace_buffer_pool[vlib_buffer_get_trace_index (b)], h,
 		    1 + n_data_words, sizeof (h[0]));
 
   h->time = vm->cpu_time_last_node_dispatch;
@@ -100,9 +102,10 @@ always_inline void
 vlib_free_trace (vlib_main_t * vm, vlib_buffer_t * b)
 {
   vlib_trace_main_t *tm = &vm->trace_main;
+  u32 trace_index = vlib_buffer_get_trace_index (b);
   vlib_validate_trace (tm, b);
-  _vec_len (tm->trace_buffer_pool[b->trace_index]) = 0;
-  pool_put_index (tm->trace_buffer_pool, b->trace_index);
+  _vec_len (tm->trace_buffer_pool[trace_index]) = 0;
+  pool_put_index (tm->trace_buffer_pool, trace_index);
 }
 
 always_inline void
@@ -149,7 +152,8 @@ vlib_trace_buffer (vlib_main_t * vm,
   do
     {
       b->flags |= VLIB_BUFFER_IS_TRACED;
-      b->trace_index = h - tm->trace_buffer_pool;
+      b->trace_handle = vlib_buffer_make_trace_handle
+	(vm->thread_index, h - tm->trace_buffer_pool);
     }
   while (follow_chain && (b = vlib_get_next_buffer (vm, b)));
 }
@@ -160,7 +164,7 @@ vlib_buffer_copy_trace_flag (vlib_main_t * vm, vlib_buffer_t * b,
 {
   vlib_buffer_t *b_target = vlib_get_buffer (vm, bi_target);
   b_target->flags |= b->flags & VLIB_BUFFER_IS_TRACED;
-  b_target->trace_index = b->trace_index;
+  b_target->trace_handle = b->trace_handle;
 }
 
 always_inline u32
diff --git a/src/vnet/ip/ip4_reassembly.c b/src/vnet/ip/ip4_reassembly.c
index 85861025b..d5f0b8a7e 100644
--- a/src/vnet/ip/ip4_reassembly.c
+++ b/src/vnet/ip/ip4_reassembly.c
@@ -294,12 +294,6 @@ ip4_reass_add_trace (vlib_main_t * vm, vlib_node_runtime_t * node,
 {
   vlib_buffer_t *b = vlib_get_buffer (vm, bi);
   vnet_buffer_opaque_t *vnb = vnet_buffer (b);
-  if (pool_is_free_index (vm->trace_main.trace_buffer_pool, b->trace_index))
-    {
-      // this buffer's trace is gone
-      b->flags &= ~VLIB_BUFFER_IS_TRACED;
-      return;
-    }
   ip4_reass_trace_t *t = vlib_add_trace (vm, node, b, sizeof (t[0]));
   t->reass_id = reass->id;
   t->action = action;
diff --git a/src/vnet/ip/ip6_reassembly.c b/src/vnet/ip/ip6_reassembly.c
index 10fc6f1f5..a8b6d2c8a 100644
--- a/src/vnet/ip/ip6_reassembly.c
+++ b/src/vnet/ip/ip6_reassembly.c
@@ -280,12 +280,6 @@ ip6_reass_add_trace (vlib_main_t * vm, vlib_node_runtime_t * node,
 {
   vlib_buffer_t *b = vlib_get_buffer (vm, bi);
   vnet_buffer_opaque_t *vnb = vnet_buffer (b);
-  if (pool_is_free_index (vm->trace_main.trace_buffer_pool, b->trace_index))
-    {
-      // this buffer's trace is gone
-      b->flags &= ~VLIB_BUFFER_IS_TRACED;
-      return;
-    }
   ip6_reass_trace_t *t = vlib_add_trace (vm, node, b, sizeof (t[0]));
   t->reass_id = reass->id;
   t->action = action;
@@ -1399,21 +1393,10 @@ ip6_reass_walk_expired (vlib_main_t * vm,
           {
             ip6_reass_t *reass = pool_elt_at_index (rt->pool, i[0]);
             u32 icmp_bi = ~0;
-            vlib_buffer_t *b = vlib_get_buffer (vm, reass->first_bi);
-            if (PREDICT_FALSE (b->flags & VLIB_BUFFER_IS_TRACED))
-              {
-                if (pool_is_free_index (vm->trace_main.trace_buffer_pool,
-                                        b->trace_index))
-                  {
-                    /* the trace is gone, don't trace this buffer anymore */
-                    b->flags &= ~VLIB_BUFFER_IS_TRACED;
-                  }
-              }
             ip6_reass_on_timeout (vm, node, rm, reass, &icmp_bi);
             if (~0 != icmp_bi)
-              {
-                vec_add1 (vec_icmp_bi, icmp_bi);
-              }
+              vec_add1 (vec_icmp_bi, icmp_bi);
+
             ip6_reass_free (rm, rt, reass);
           }
           /* *INDENT-ON* */
@@ -1433,18 +1416,7 @@ ip6_reass_walk_expired (vlib_main_t * vm,
 	      u32 bi = vec_pop (vec_icmp_bi);
 	      vlib_buffer_t *b = vlib_get_buffer (vm, bi);
 	      if (PREDICT_FALSE (b->flags & VLIB_BUFFER_IS_TRACED))
-		{
-		  if (pool_is_free_index (vm->trace_main.trace_buffer_pool,
-					  b->trace_index))
-		    {
-		      /* the trace is gone, don't trace this buffer anymore */
-		      b->flags &= ~VLIB_BUFFER_IS_TRACED;
-		    }
-		  else
-		    {
-		      trace_frame = 1;
-		    }
-		}
+		trace_frame = 1;
 	      b->error = node->errors[IP6_ERROR_REASS_TIMEOUT];
 	      to_next[0] = bi;
 	      ++f->n_vectors;
