// Code generated by protoc-gen-go. DO NOT EDIT.
// source: endpoints.proto

/*
Package endpoints is a generated protocol buffer package.

Package endpoints defines data model for Kubernetes service endpoints.

It is generated from these files:
	endpoints.proto

It has these top-level messages:
	ObjectReference
	EndpointSubset
	Endpoints
*/
package endpoints

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// ObjectReference contains enough information to let you inspect
// or modify the referred object.
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type ObjectReference struct {
	// Kind of the referent.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind string `protobuf:"bytes,1,opt,name=kind" json:"kind,omitempty"`
	// Namespace of the referent.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	// +optional
	Namespace string `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	// Name of the referent.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// +optional
	Name string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// UID of the referent.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	// +optional
	Uid string `protobuf:"bytes,4,opt,name=uid" json:"uid,omitempty"`
	// API version of the referent.
	// +optional
	ApiVersion string `protobuf:"bytes,5,opt,name=api_version,json=apiVersion" json:"api_version,omitempty"`
	// Specific resourceVersion to which this reference is made, if any.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
	// +optional
	ResourceVersion string `protobuf:"bytes,6,opt,name=resource_version,json=resourceVersion" json:"resource_version,omitempty"`
}

func (m *ObjectReference) Reset()                    { *m = ObjectReference{} }
func (m *ObjectReference) String() string            { return proto.CompactTextString(m) }
func (*ObjectReference) ProtoMessage()               {}
func (*ObjectReference) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ObjectReference) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *ObjectReference) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ObjectReference) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectReference) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *ObjectReference) GetApiVersion() string {
	if m != nil {
		return m.ApiVersion
	}
	return ""
}

func (m *ObjectReference) GetResourceVersion() string {
	if m != nil {
		return m.ResourceVersion
	}
	return ""
}

// EndpointSubset is a group of addresses with a common set of ports. The
// expanded set of endpoints is the Cartesian product of Addresses x Ports.
// For example, given:
//   {
//     Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
//     Ports:     [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
//   }
// The resulting set of endpoints can be viewed as:
//     a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],
//     b: [ 10.10.1.1:309, 10.10.2.2:309 ]
type EndpointSubset struct {
	// IP addresses which offer the related ports that are marked as
	// ready. These endpoints should be considered safe for load balancers
	// and clients to utilize.
	// +optional
	Addresses []*EndpointSubset_EndpointAddress `protobuf:"bytes,1,rep,name=addresses" json:"addresses,omitempty"`
	// IP addresses which offer the related ports but are not currently
	// marked as ready because they have not yet finished starting, have
	// recently failed a readiness check, or have recently failed a
	// liveness check.
	// +optional
	NotReadyAddresses []*EndpointSubset_EndpointAddress `protobuf:"bytes,2,rep,name=not_ready_addresses,json=notReadyAddresses" json:"not_ready_addresses,omitempty"`
	// Port numbers available on the related IP addresses.
	// +optional
	Ports []*EndpointSubset_EndpointPort `protobuf:"bytes,3,rep,name=ports" json:"ports,omitempty"`
}

func (m *EndpointSubset) Reset()                    { *m = EndpointSubset{} }
func (m *EndpointSubset) String() string            { return proto.CompactTextString(m) }
func (*EndpointSubset) ProtoMessage()               {}
func (*EndpointSubset) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *EndpointSubset) GetAddresses() []*EndpointSubset_EndpointAddress {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *EndpointSubset) GetNotReadyAddresses() []*EndpointSubset_EndpointAddress {
	if m != nil {
		return m.NotReadyAddresses
	}
	return nil
}

func (m *EndpointSubset) GetPorts() []*EndpointSubset_EndpointPort {
	if m != nil {
		return m.Ports
	}
	return nil
}

// EndpointAddress is a tuple that describes single IP address.
type EndpointSubset_EndpointAddress struct {
	// The IP of this endpoint.
	// May not be loopback (127.0.0.0/8), link-local (169.254.0.0/16),
	// or link-local multicast ((224.0.0.0/24).
	// IPv6 is also accepted but not fully supported on all platforms.
	// Also, certain kubernetes components, like kube-proxy, are not
	// IPv6 ready.
	Ip string `protobuf:"bytes,1,opt,name=ip" json:"ip,omitempty"`
	// The Hostname of this endpoint
	// +optional
	HostName string `protobuf:"bytes,2,opt,name=host_name,json=hostName" json:"host_name,omitempty"`
	// Optional: Node hosting this endpoint. This can be used to
	// determine endpoints local to a node.
	// +optional
	NodeName string `protobuf:"bytes,3,opt,name=node_name,json=nodeName" json:"node_name,omitempty"`
	// Reference to object providing the endpoint.
	TargetRef *ObjectReference `protobuf:"bytes,4,opt,name=target_ref,json=targetRef" json:"target_ref,omitempty"`
}

func (m *EndpointSubset_EndpointAddress) Reset()         { *m = EndpointSubset_EndpointAddress{} }
func (m *EndpointSubset_EndpointAddress) String() string { return proto.CompactTextString(m) }
func (*EndpointSubset_EndpointAddress) ProtoMessage()    {}
func (*EndpointSubset_EndpointAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{1, 0}
}

func (m *EndpointSubset_EndpointAddress) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *EndpointSubset_EndpointAddress) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *EndpointSubset_EndpointAddress) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *EndpointSubset_EndpointAddress) GetTargetRef() *ObjectReference {
	if m != nil {
		return m.TargetRef
	}
	return nil
}

// EndpointPort is a tuple that describes a single port.
type EndpointSubset_EndpointPort struct {
	// The name of this port (corresponds to ServicePort.Name).
	// Must be a DNS_LABEL.
	// Optional only if one port is defined.
	// +optional
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The port number of the endpoint.
	Port int32 `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
	// The IP protocol for this port.
	// Must be UDP or TCP.
	// Default is TCP.
	// +optional
	Protocol string `protobuf:"bytes,3,opt,name=protocol" json:"protocol,omitempty"`
}

func (m *EndpointSubset_EndpointPort) Reset()                    { *m = EndpointSubset_EndpointPort{} }
func (m *EndpointSubset_EndpointPort) String() string            { return proto.CompactTextString(m) }
func (*EndpointSubset_EndpointPort) ProtoMessage()               {}
func (*EndpointSubset_EndpointPort) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 1} }

func (m *EndpointSubset_EndpointPort) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EndpointSubset_EndpointPort) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *EndpointSubset_EndpointPort) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

// Endpoints is a collection of endpoints that implement the actual service. Example:
//   Name: "mysvc",
//   Subsets: [
//     {
//       Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
//       Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
//     },
//     {
//       Addresses: [{"ip": "10.10.3.3"}],
//       Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
//     },
//  ]
type Endpoints struct {
	// Name of the service unique within the namespace for which these
	// Endpoint Subsets apply to.
	// Cannot be updated.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Namespace for service for which these endpoint subsets apply to.
	// An empty namespace is equivalent to the "default" namespace, but
	// "default" is the canonical representation used in the key for a
	// key-value store.
	// Cannot be updated.
	Namespace string `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	// The set of all endpoints is the union of all subsets. Addresses are
	// placed into subsets according to the IPs they share. A single address
	// with multiple ports, some of which are ready and some of which are not
	// (because they come from different containers) will result in the address
	// being displayed in different subsets for the different ports. No address
	// will appear in both Addresses and NotReadyAddresses in the same subset.
	// Sets of addresses and ports that comprise a service.
	EndpointSubsets []*EndpointSubset `protobuf:"bytes,3,rep,name=endpoint_subsets,json=endpointSubsets" json:"endpoint_subsets,omitempty"`
}

func (m *Endpoints) Reset()                    { *m = Endpoints{} }
func (m *Endpoints) String() string            { return proto.CompactTextString(m) }
func (*Endpoints) ProtoMessage()               {}
func (*Endpoints) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Endpoints) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Endpoints) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Endpoints) GetEndpointSubsets() []*EndpointSubset {
	if m != nil {
		return m.EndpointSubsets
	}
	return nil
}

func init() {
	proto.RegisterType((*ObjectReference)(nil), "endpoints.ObjectReference")
	proto.RegisterType((*EndpointSubset)(nil), "endpoints.EndpointSubset")
	proto.RegisterType((*EndpointSubset_EndpointAddress)(nil), "endpoints.EndpointSubset.EndpointAddress")
	proto.RegisterType((*EndpointSubset_EndpointPort)(nil), "endpoints.EndpointSubset.EndpointPort")
	proto.RegisterType((*Endpoints)(nil), "endpoints.Endpoints")
}

func init() { proto.RegisterFile("endpoints.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 406 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0xcd, 0x8a, 0xdb, 0x30,
	0x10, 0xc6, 0x76, 0x12, 0xa2, 0x49, 0x89, 0x53, 0xf5, 0xe2, 0x3a, 0x85, 0x86, 0x1c, 0x4a, 0x72,
	0xc9, 0x21, 0x3d, 0x15, 0x7a, 0x09, 0xb4, 0xf4, 0xd6, 0x16, 0x15, 0x0a, 0x3d, 0x19, 0xc7, 0x9e,
	0x74, 0xb5, 0x3f, 0x92, 0x90, 0x94, 0x85, 0x3d, 0xef, 0x3b, 0xec, 0x9b, 0xec, 0xf3, 0xec, 0xab,
	0x2c, 0x92, 0xe3, 0x9f, 0x0d, 0xfb, 0xc3, 0xde, 0x66, 0x3e, 0xcd, 0x7c, 0xfe, 0x66, 0xbe, 0x31,
	0xc4, 0x28, 0x4a, 0x25, 0xb9, 0xb0, 0x66, 0xa5, 0xb4, 0xb4, 0x92, 0x92, 0x06, 0x98, 0xdf, 0x06,
	0x10, 0xff, 0xda, 0x9e, 0x62, 0x61, 0x19, 0xee, 0x50, 0xa3, 0x28, 0x90, 0x52, 0xe8, 0x9d, 0x71,
	0x51, 0x26, 0xc1, 0x2c, 0x58, 0x10, 0xe6, 0x63, 0xfa, 0x01, 0x88, 0xc8, 0x2f, 0xd0, 0xa8, 0xbc,
	0xc0, 0x24, 0xf4, 0x0f, 0x2d, 0xe0, 0x3a, 0x5c, 0x92, 0x44, 0x55, 0x87, 0x8b, 0xe9, 0x04, 0xa2,
	0x3d, 0x2f, 0x93, 0x9e, 0x87, 0x5c, 0x48, 0x3f, 0xc2, 0x28, 0x57, 0x3c, 0xbb, 0x44, 0x6d, 0xb8,
	0x14, 0x49, 0xdf, 0xbf, 0x40, 0xae, 0xf8, 0xdf, 0x0a, 0xa1, 0x4b, 0x98, 0x68, 0x34, 0x72, 0xaf,
	0x0b, 0x6c, 0xaa, 0x06, 0xbe, 0x2a, 0xae, 0xf1, 0x43, 0xe9, 0xfc, 0x2e, 0x82, 0xf1, 0xf7, 0xc3,
	0x14, 0x7f, 0xf6, 0x5b, 0x83, 0x96, 0xfe, 0x00, 0x92, 0x97, 0xa5, 0x46, 0x63, 0xd0, 0x24, 0xc1,
	0x2c, 0x5a, 0x8c, 0xd6, 0xcb, 0x55, 0x3b, 0xfa, 0xc3, 0xea, 0x26, 0xdd, 0x54, 0x2d, 0xac, 0xed,
	0xa5, 0xff, 0xe0, 0x9d, 0x90, 0x36, 0xd3, 0x98, 0x97, 0x57, 0x59, 0x4b, 0x19, 0xbe, 0x96, 0xf2,
	0xad, 0x90, 0x96, 0x39, 0x92, 0x4d, 0x43, 0xfd, 0x15, 0xfa, 0x4a, 0x6a, 0x6b, 0x92, 0xc8, 0x93,
	0x7d, 0x7a, 0x99, 0xec, 0xb7, 0xd4, 0x96, 0x55, 0x4d, 0xe9, 0x4d, 0x00, 0xf1, 0xd1, 0x47, 0xe8,
	0x18, 0x42, 0xae, 0x0e, 0x56, 0x85, 0x5c, 0xd1, 0x29, 0x90, 0x13, 0x69, 0x6c, 0xe6, 0xfd, 0xa8,
	0x8c, 0x1a, 0x3a, 0xe0, 0xa7, 0xf3, 0x64, 0x0a, 0x44, 0xc8, 0x12, 0xb3, 0x8e, 0x59, 0x43, 0x07,
	0xf8, 0xc7, 0x2f, 0x00, 0x36, 0xd7, 0xff, 0xd1, 0x4d, 0xbe, 0xf3, 0xbe, 0x8d, 0xd6, 0x69, 0x47,
	0xe0, 0xd1, 0x99, 0x30, 0x52, 0x55, 0x33, 0xdc, 0xa5, 0x0c, 0xde, 0x74, 0xf5, 0x36, 0xf7, 0x10,
	0x74, 0xee, 0x81, 0x42, 0xcf, 0x4d, 0xe1, 0x35, 0xf5, 0x99, 0x8f, 0x69, 0x0a, 0x43, 0x7f, 0x91,
	0x85, 0x3c, 0xaf, 0xe5, 0xd4, 0xf9, 0xfc, 0x3a, 0x00, 0x52, 0x93, 0x9a, 0x47, 0x19, 0x9f, 0xbf,
	0xc9, 0x6f, 0x30, 0xa9, 0xb5, 0x67, 0xc6, 0xef, 0xb4, 0xde, 0xfa, 0xfb, 0x27, 0xb7, 0xce, 0x9a,
	0x5f, 0xa5, 0xca, 0xcd, 0x76, 0xe0, 0xf5, 0x7c, 0xbe, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x2e, 0xa0,
	0xbb, 0x27, 0x44, 0x03, 0x00, 0x00,
}
