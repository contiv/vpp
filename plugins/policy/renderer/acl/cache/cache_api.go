/*
 * // Copyright (c) 2017 Cisco and/or its affiliates.
 * //
 * // Licensed under the Apache License, Version 2.0 (the "License");
 * // you may not use this file except in compliance with the License.
 * // You may obtain a copy of the License at:
 * //
 * //     http://www.apache.org/licenses/LICENSE-2.0
 * //
 * // Unless required by applicable law or agreed to in writing, software
 * // distributed under the License is distributed on an "AS IS" BASIS,
 * // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * // See the License for the specific language governing permissions and
 * // limitations under the License.
 */

package cache

import (
	"fmt"

	"github.com/contiv/vpp/plugins/policy/renderer"
)

// ContivRuleCacheAPI defines API of a cache used to store Contiv Rules as *lists*.
// The cache allows renderer to easily calculate the minimal set of changes
// that need to be applied in a given transaction. Furthermore, the cache
// automatically groups ingress/egress rules per-interface into lists
// (see ContivRuleList) with auto-generated IDs that are shared between
// interfaces with equivalent configuration.
// If supported by the destination network stack, the renderer may install
// a list of ingress/egress rules only once and share it among multiple
// associated interfaces.
type ContivRuleCacheAPI interface {
	// NewTxn starts a new transaction. The changes are reflected in the cache
	// only after Commit() is called.
	NewTxn() Txn

	// Resync completely replaces the existing cache content with the supplied
	// data.
	Resync(ingress, egress []*ContivRuleList) error

	// LookupByInterface returns rules assigned to a given interface grouped
	// into lists by the traffic direction. Interfaces with equal ingress and/or
	// egress configuration will share the same lists (same IDs).
	LookupByInterface(ifName string) (ingress, egress *ContivRuleList)

	// AllInterfaces returns set of all interfaces with known configuration
	// since the last resync.
	AllInterfaces() InterfaceSet
}

// Txn defines API of ContivRuleCache transaction.
type Txn interface {
	// Update changes the list of rules for a given interface.
	// The change is applied into the cache during commit.
	// Run Changes() before Commit() to learn the set of pending updates (merged
	// to minimal diff).
	Update(ifName string, ingress []*renderer.ContivRule, egress []*renderer.ContivRule) error

	// Changes calculates a minimalistic set of changes prepared in the
	// transaction up to this point.
	// Must be run before Commit().
	Changes() (ingress, egress []*TxnChange)

	// AllInterfaces returns set of all interfaces included in the transaction.
	AllInterfaces() InterfaceSet

	// Commit applies the changes into the underlying cache.
	Commit() error
}

// ContivRuleList is a grouping of all rules applied on one or shared by multiple
// interfaces on the ingress or egress side.
// Rules are not mutable. Only the list of associated interfaces may change.
type ContivRuleList struct {
	// ID is generated by the cache to uniquely identify the list among all
	// ingress and egress lists.
	// The string starts with a prefix "ingress-" or "egress-" and continues
	// with a randomly generated suffix. IDs of lists passed to Resync() should
	// also follow this naming scheme or the operation will get rejected.
	ID string

	// Rules applied on the ingress or the egress side for one or multiple
	// interfaces. For a given ContivRuleList, Rules are always the same.
	Rules []*renderer.ContivRule

	// Set of all interfaces associated with this list.
	// Empty for removed list.
	Interfaces InterfaceSet

	// Private can be used by renderer to store the configuration of rules from
	// the list in the format used by the destination network stack.
	Private interface{}
}

// String converts ContivRuleList (pointer) into a human-readable string
// representation.
func (crl *ContivRuleList) String() string {
	return fmt.Sprintf("Rule List %s <rules: %v, ifs: %s>",
		crl.ID, crl.Rules, crl.Interfaces)
}

// TxnChange represents change in the ContivRuleCache to be performed
// by a transaction.
type TxnChange struct {
	// List of rules that have been been affected by the transaction.
	// Possible changes:
	//   - new list
	//   - removed list
	//   - changed assignment of interfaces
	// List content itself is not mutable. Different content is treated
	// as a new list (and the original list may loose some interfaces
	// or all of them and get removed)
	List *ContivRuleList

	// Set of interfaces previously assigned to the list.
	// Empty for newly added list.
	PreviousInterfaces InterfaceSet
}

// String converts TxnChange (pointer) into a human-readable string
// representation.
func (tch *TxnChange) String() string {
	return fmt.Sprintf("Change <list: %s, prevIfs: %s>",
		tch.List, tch.PreviousInterfaces)
}

// InterfaceSet is a set of interface names.
type InterfaceSet map[string]struct{}
